{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dash-Forecast Dash-Forecast allows you to easily build forecasting dashboards. Why Dash-Forecast Judgment and decision making research shows that visual tools are an easy and effective way to boost forecasting accuracy . Dash-Forecast is a high-level API for creating beautiful forecasting visualizations and statistical summaries. Installation $ pip install dash-fcast Quickstart In just a few lines of code, we'll create an app that gives you: An intuitive 'bounds and moments' forecast elicitation An editable data table representation of the forecast Probability density function and cumulative distribution function line plots of the forecast A bar plot of the data table Create a file app.py : import dash_fcast as fcast import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Moments(id='Forecast'), html.Br(), fcast.Table( id='Table', datatable={'editable': True, 'row_deletable': True}, row_addable=True ), html.Div(id='graphs') ], className='container') dist.Moments.register_callbacks(app) fcast.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [ Input(dist.Moments.get_id('Forecast'), 'children'), Input(fcast.Table.get_id('Table'), 'children') ] ) def update_graphs(dist_state, table_state): distribution = dist.Moments.load(dist_state) table = fcast.Table.load(table_state) pdf = go.Figure([distribution.pdf_plot(), table.bar_plot('Forecast')]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run your application with: $ python app.py Open your browser and navigate to http://localhost:8050/ . Citation @software{bowen2020dash-fcast, author = {Dillon Bowen}, title = {Dash-Forecast}, url = {https://dsbowen.github.io/dash-fcast/}, date = {2020-09-11}, } License Users must cite this package in any publications which use it. It is licensed with the MIT License . Acknowledgements The following collaborators deserve special acknowledgement: David Melgin, for the bounds and moments elicitation Ezra Karger, whose non-parametric elicitation methods helped inspire my 'tabular elicitation' Sarah Reed, for feedback on the front-end design I would also like to thank the Tetlock Lab, whose weekly presentations inspired various aspects of this package, including Zachary Jacobs' and Ian Lustick's 'first approximation algorithm', Scott Page's multi-model thinking, and Annie Duke's presentation on intuitively eliciting predictions.","title":"Home"},{"location":"#dash-forecast","text":"Dash-Forecast allows you to easily build forecasting dashboards.","title":"Dash-Forecast"},{"location":"#why-dash-forecast","text":"Judgment and decision making research shows that visual tools are an easy and effective way to boost forecasting accuracy . Dash-Forecast is a high-level API for creating beautiful forecasting visualizations and statistical summaries.","title":"Why Dash-Forecast"},{"location":"#installation","text":"$ pip install dash-fcast","title":"Installation"},{"location":"#quickstart","text":"In just a few lines of code, we'll create an app that gives you: An intuitive 'bounds and moments' forecast elicitation An editable data table representation of the forecast Probability density function and cumulative distribution function line plots of the forecast A bar plot of the data table Create a file app.py : import dash_fcast as fcast import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Moments(id='Forecast'), html.Br(), fcast.Table( id='Table', datatable={'editable': True, 'row_deletable': True}, row_addable=True ), html.Div(id='graphs') ], className='container') dist.Moments.register_callbacks(app) fcast.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [ Input(dist.Moments.get_id('Forecast'), 'children'), Input(fcast.Table.get_id('Table'), 'children') ] ) def update_graphs(dist_state, table_state): distribution = dist.Moments.load(dist_state) table = fcast.Table.load(table_state) pdf = go.Figure([distribution.pdf_plot(), table.bar_plot('Forecast')]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run your application with: $ python app.py Open your browser and navigate to http://localhost:8050/ .","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020dash-fcast, author = {Dillon Bowen}, title = {Dash-Forecast}, url = {https://dsbowen.github.io/dash-fcast/}, date = {2020-09-11}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"License"},{"location":"#acknowledgements","text":"The following collaborators deserve special acknowledgement: David Melgin, for the bounds and moments elicitation Ezra Karger, whose non-parametric elicitation methods helped inspire my 'tabular elicitation' Sarah Reed, for feedback on the front-end design I would also like to thank the Tetlock Lab, whose weekly presentations inspired various aspects of this package, including Zachary Jacobs' and Ian Lustick's 'first approximation algorithm', Scott Page's multi-model thinking, and Annie Duke's presentation on intuitively eliciting predictions.","title":"Acknowledgements"},{"location":"table/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Table display dash_fcast. Table class dash_fcast. Table ( id, bins=[0, 0.25, 0.5, 0.75, 1], datatable={}, row_addable=False ) [source] Parameters and attributes: id : str Table identifier. bins : list, default=[0, .25, .5, .75, 1] List of bin 'breakpoints'. Bins are contiguous. The first bin starts at bins[0] . The last bin ends at bins[-1] . datatable : dict, default={} Keyword arguments passed to the datatable in which table data are displayed. row_addable : bool, default=False Indicates that users can add rows to the table. Methods get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the table. Returns: id dictionary : dict Dictionary identifier. get_table ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for dash_table.DataTable . Returns: data table : dash_table.DataTable get_columns ( self ) [source] Returns: columns : list of dicts List of column dictionaries in dash_table columns format. get_data ( self, bins=None, distributions=[], data=[] ) [source] Parameters: bins : list of scalars or None, default=None If None this method uses self.bins . distributions : list, default=[] List of distributions like those specified in dash_fcast.distributions . data : list of dicts, default=[] Existing data in records format. If a bin matches existing data, that record is returned without updating the distribution pdfs. Returns: records : list List of records (dictionaries) mapping column ids to data entry. register_callbacks ( app ) [source] Register dash callbacks for table display. Parameters: app : dash.Dash App with which to register the callbacks. dump ( self ) [source] Returns: state_dict : JSON dict Dictionary representing the table state. load ( cls, state_dict ) [source] Parameters: state_dict : JSON dict Table state dictionary; output from dash_fcast.Table.dump . Returns: table : dash_fcast.Table Table specified by the table state. bar_plot ( self, col, **kwargs ) [source] Parameters: col : str ID of the column (distribution) to plot. **kwargs : Keyword arguments passed to go.Bar . Returns: bar plot : go.Bar","title":"Table"},{"location":"table/#table-display","text":"","title":"Table display"},{"location":"table/#dash_fcasttable","text":"class dash_fcast. Table ( id, bins=[0, 0.25, 0.5, 0.75, 1], datatable={}, row_addable=False ) [source] Parameters and attributes: id : str Table identifier. bins : list, default=[0, .25, .5, .75, 1] List of bin 'breakpoints'. Bins are contiguous. The first bin starts at bins[0] . The last bin ends at bins[-1] . datatable : dict, default={} Keyword arguments passed to the datatable in which table data are displayed. row_addable : bool, default=False Indicates that users can add rows to the table.","title":"dash_fcast.Table"},{"location":"table/#methods","text":"get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the table. Returns: id dictionary : dict Dictionary identifier. get_table ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for dash_table.DataTable . Returns: data table : dash_table.DataTable get_columns ( self ) [source] Returns: columns : list of dicts List of column dictionaries in dash_table columns format. get_data ( self, bins=None, distributions=[], data=[] ) [source] Parameters: bins : list of scalars or None, default=None If None this method uses self.bins . distributions : list, default=[] List of distributions like those specified in dash_fcast.distributions . data : list of dicts, default=[] Existing data in records format. If a bin matches existing data, that record is returned without updating the distribution pdfs. Returns: records : list List of records (dictionaries) mapping column ids to data entry. register_callbacks ( app ) [source] Register dash callbacks for table display. Parameters: app : dash.Dash App with which to register the callbacks. dump ( self ) [source] Returns: state_dict : JSON dict Dictionary representing the table state. load ( cls, state_dict ) [source] Parameters: state_dict : JSON dict Table state dictionary; output from dash_fcast.Table.dump . Returns: table : dash_fcast.Table Table specified by the table state. bar_plot ( self, col, **kwargs ) [source] Parameters: col : str ID of the column (distribution) to plot. **kwargs : Keyword arguments passed to go.Bar . Returns: bar plot : go.Bar","title":"Methods"},{"location":"distributions/moments/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Moments distribution This elicitation method asks forecasters to input the 'bounds and moments' of the distribution. (Specifically, the moments are the mean and standard deviation). It then fits a distribution based on these inputs: Lower bound and upper bound => uniform Lower bound and mean or standard deviation => exponential Upper bound and mean or standard deviation => 'reflected' exponential Mean and standard deviation => Gaussian Otherwise => non-parametric maximum entropy distribution. See https://dsbowen.github.io/smoother/ . Examples In app.py : import dash_fcast as fcast import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Moments(id='Forecast'), html.Br(), fcast.Table( id='Table', datatable={'editable': True, 'row_deletable': True}, row_addable=True ), html.Div(id='graphs') ], className='container') dist.Moments.register_callbacks(app) fcast.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [ Input(dist.Moments.get_id('Forecast'), 'children'), Input(fcast.Table.get_id('Table'), 'children') ] ) def update_graphs(dist_state, table_state): distribution = dist.Moments.load(dist_state) table = fcast.Table.load(table_state) pdf = go.Figure([distribution.pdf_plot(), table.bar_plot('Forecast')]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run the app with: $ python app.py Open your browser and navigate to http://localhost:8050/ . dash_fcast.distributions. Moments class dash_fcast.distributions. Moments ( id, lb=0, ub=1, mean=None, std=None, *args, **kwargs ) [source] Distribution generated from moments elicitation. Parameters: id : str Distribution identifier. lb : scalar or None, default=0 Lower bound of the distribution. F(x)=0 for all x<lb . If None , the distribution has no lower bound. ub : scalar or None, default=1 Upper bound of the distribution. F(x)=1 for all x>ub . If None , the distribution has no upper bound. mean : scalar or None, default=None Mean of the distribution. If None , the mean is inferred as halfway between the lower and upper bound. std : scalar or None, default=None Standard deviation of the distribution. If None , the standard deviation is inferred as the standard deviation which maximizes entropy. *args, **kwargs : Arguments and keyword arguments are passed to the smoother constructor. Attributes: id : str Set from the id parameter. Methods get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the moments distribution. Returns: id dictionary : dict Dictionary identifier. elicitation ( self, lb=0, ub=1, mean=None, std=None ) [source] Creates the layout for eliciting bounds and moments. Parameters for this method are analogous to the constructor parameters. Parameters: lb : scalar, default=0 ub : scalar, default=1 mean : scalar or None, default=None std : scalar or None, default=None decimals : int, default=2 Number of decimals to which the recommended maximum standard deviation is rounded. Returns: layout : list of dash elements. Elicitation layout. register_callbacks ( app, decimals=2 ) [source] Register dash callbacks for moments distributions. Parameters: app : dash.Dash App with which to register callbacks. decimals : int, default=2 Number of decimals to which to round the standard deviation placeholder. fit ( self, lb=None, ub=None, mean=None, std=None ) [source] Fit the smoother given bounds and moments constraints. Parameters are analogous to those of the constructor. Parameters: lb : scalar or None, default=None ub : scalar or None, default=None mean : scalar or None, default=None std : scalar or None, default=None Returns: self : dash_fcast.distributions.Moments dump ( self ) [source] Returns: state dictionary : str (JSON) load ( cls, state_dict ) [source] Parameters: state_dict : str (JSON) Moments distribution state dictionary (output of Moments.dump ). Returns: distribution : dash_fcast.distributions.Moments Moments distribution specified by the state dictionary. mean ( self ) [source] std ( self ) [source] pdf ( self, x ) [source] cdf ( self, x ) [source] ppf ( self, q ) [source] pdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments passed to go.Scatter . Returns: scatter : go.Scatter Scatter plot of the probability density function. cdf_plot ( self, **kwargs ) [source] Parameters: ** kwargs : Keyword arguments passed to go.Scatter . Returns: scatter : go.Scatter Scatter plot of the cumulative distribution function.","title":"Moments"},{"location":"distributions/moments/#moments-distribution","text":"This elicitation method asks forecasters to input the 'bounds and moments' of the distribution. (Specifically, the moments are the mean and standard deviation). It then fits a distribution based on these inputs: Lower bound and upper bound => uniform Lower bound and mean or standard deviation => exponential Upper bound and mean or standard deviation => 'reflected' exponential Mean and standard deviation => Gaussian Otherwise => non-parametric maximum entropy distribution. See https://dsbowen.github.io/smoother/ .","title":"Moments distribution"},{"location":"distributions/moments/#examples","text":"In app.py : import dash_fcast as fcast import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Moments(id='Forecast'), html.Br(), fcast.Table( id='Table', datatable={'editable': True, 'row_deletable': True}, row_addable=True ), html.Div(id='graphs') ], className='container') dist.Moments.register_callbacks(app) fcast.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [ Input(dist.Moments.get_id('Forecast'), 'children'), Input(fcast.Table.get_id('Table'), 'children') ] ) def update_graphs(dist_state, table_state): distribution = dist.Moments.load(dist_state) table = fcast.Table.load(table_state) pdf = go.Figure([distribution.pdf_plot(), table.bar_plot('Forecast')]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run the app with: $ python app.py Open your browser and navigate to http://localhost:8050/ .","title":"Examples"},{"location":"distributions/moments/#dash_fcastdistributionsmoments","text":"class dash_fcast.distributions. Moments ( id, lb=0, ub=1, mean=None, std=None, *args, **kwargs ) [source] Distribution generated from moments elicitation. Parameters: id : str Distribution identifier. lb : scalar or None, default=0 Lower bound of the distribution. F(x)=0 for all x<lb . If None , the distribution has no lower bound. ub : scalar or None, default=1 Upper bound of the distribution. F(x)=1 for all x>ub . If None , the distribution has no upper bound. mean : scalar or None, default=None Mean of the distribution. If None , the mean is inferred as halfway between the lower and upper bound. std : scalar or None, default=None Standard deviation of the distribution. If None , the standard deviation is inferred as the standard deviation which maximizes entropy. *args, **kwargs : Arguments and keyword arguments are passed to the smoother constructor. Attributes: id : str Set from the id parameter.","title":"dash_fcast.distributions.Moments"},{"location":"distributions/moments/#methods","text":"get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the moments distribution. Returns: id dictionary : dict Dictionary identifier. elicitation ( self, lb=0, ub=1, mean=None, std=None ) [source] Creates the layout for eliciting bounds and moments. Parameters for this method are analogous to the constructor parameters. Parameters: lb : scalar, default=0 ub : scalar, default=1 mean : scalar or None, default=None std : scalar or None, default=None decimals : int, default=2 Number of decimals to which the recommended maximum standard deviation is rounded. Returns: layout : list of dash elements. Elicitation layout. register_callbacks ( app, decimals=2 ) [source] Register dash callbacks for moments distributions. Parameters: app : dash.Dash App with which to register callbacks. decimals : int, default=2 Number of decimals to which to round the standard deviation placeholder. fit ( self, lb=None, ub=None, mean=None, std=None ) [source] Fit the smoother given bounds and moments constraints. Parameters are analogous to those of the constructor. Parameters: lb : scalar or None, default=None ub : scalar or None, default=None mean : scalar or None, default=None std : scalar or None, default=None Returns: self : dash_fcast.distributions.Moments dump ( self ) [source] Returns: state dictionary : str (JSON) load ( cls, state_dict ) [source] Parameters: state_dict : str (JSON) Moments distribution state dictionary (output of Moments.dump ). Returns: distribution : dash_fcast.distributions.Moments Moments distribution specified by the state dictionary. mean ( self ) [source] std ( self ) [source] pdf ( self, x ) [source] cdf ( self, x ) [source] ppf ( self, q ) [source] pdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments passed to go.Scatter . Returns: scatter : go.Scatter Scatter plot of the probability density function. cdf_plot ( self, **kwargs ) [source] Parameters: ** kwargs : Keyword arguments passed to go.Scatter . Returns: scatter : go.Scatter Scatter plot of the cumulative distribution function.","title":"Methods"},{"location":"distributions/table/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Tabular distribution Examples In app.py : import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Table( id='Forecast', datatable={'editable': True, 'row_deletable': True}, row_addable=True, smoother=True ), html.Div(id='graphs') ], className='container') dist.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [Input(dist.Table.get_id('Forecast'), 'children')] ) def update_graphs(dist_state): distribution = dist.Table.load(dist_state) pdf = go.Figure([distribution.pdf_plot(), distribution.bar_plot()]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run the app with: $ python app.py Open your browser and navigate to http://localhost:8050/ . dash_fcast.distributions. Table class dash_fcast.distributions. Table ( id, bins=[0, 0.25, 0.5, 0.75, 1], pdf=[0.25, 0.25, 0.25, 0.25], datatable={}, row_addable=False, smoother=False, *args, **kwargs ) [source] Tabular distribution elicitation. Parameters and attributes: id : str, default Distribution identifier. bins : list of scalars, default=[0, .25, .5, .75, 1] List of 'break points' for the bins. The first bin starts at bins[0] . The last bin ends at bins[-1] . pdf : list of scalars, default=[.25, .25, .25, .25] Probability density function. This is the amount of probability mass in each bin. Must sum to 1 and len(pdf) must be len(bins)-1 . datatable : dict, default={} Keyword arguments for the datatable associated with the table distribution. See https://dash.plotly.com/datatable . row_addable : bool, default=False Indicates whether the forecaster can add rows. smoother : bool, default=False Indicates whether to use a smoother for interpolation. See https://dsbowen.github.io/smoother/ . *args, **kwargs : Arguments and keyword arguments passed to super().__init__ . Methods get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the moments distribution. Returns: id dictionary : dict Dictionary identifier. elicitation ( self, bins=[0, 0.25, 0.5, 0.75, 1], pdf=[0.25, 0.25, 0.25, 0.25], datatable={}, row_addable=False ) [source] Parameters: bins : list of scalars or numpy.array, default=[0, .25, .5, .75, 1] pdf : list of scalars or numpy.array, default=[.25, .25, .25, .25] datatable : dict, default={} row_addable : bool, default=False Returns: elicitation elements : list of dash elements Dash elements used to elicit the distribution. get_columns ( self ) [source] Returns: columns : list of dict List of dictionaries specifying the datatable columns. See https://dash.plotly.com/datatable , get_data ( self, bins=None, pdf=None ) [source] Parameters: bins : list of float or numpy.array or None, default=None If None , use self.bins . pdf : list of float or numpy.array or None, default=None If None , use self.pdf . Returns: records : list of dict Datatable data in records format. register_callbacks ( app ) [source] Register dash callbacks for table distributions. Parameters: app : dash.Dash App with which to register callbacks. fit ( self, bins=None, pdf=None, derivative=2 ) [source] Fit the smoother given masses constraints. Parameters: bins : list of float or numpy.array Ordered list of bin break points. If None , use self.bins . pdf : list of float or numpy.array Probability density function. This is the amount of probability mass in each bin. Must sum to 1 and len(pdf) should be len(bins)-1 . If None , use self.pdf . derivative : int, default=2 Deriviate of the derivative smoothing function to maximize. e.g. 2 means the smoother will minimize the mean squaure second derivative. Returns: self : dump ( self ) [source] Dump the table distribution state dictionary in JSON format. Returns: state : dict, JSON load ( cls, state_dict ) [source] Load a table distribution from its state dictionary. Parameters: state_dict : dict Output of Table.dump . Returns: table : Table pdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Scatter . Returns: scatter : go.Scatter. Scatter plot of the pdf. cdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Scatter . Returns: scatter : go.Scatter Scatter plot of the cdf. bar_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Bar . Returns: bar plot : go.Bar Bar plot of the pdf in the datatable.","title":"Table"},{"location":"distributions/table/#tabular-distribution","text":"","title":"Tabular distribution"},{"location":"distributions/table/#examples","text":"In app.py : import dash_fcast.distributions as dist import dash import dash_bootstrap_components as dbc import dash_core_components as dcc import dash_html_components as html import plotly.graph_objects as go from dash.dependencies import Input, Output app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP]) app.layout = html.Div([ html.Br(), dist.Table( id='Forecast', datatable={'editable': True, 'row_deletable': True}, row_addable=True, smoother=True ), html.Div(id='graphs') ], className='container') dist.Table.register_callbacks(app) @app.callback( Output('graphs', 'children'), [Input(dist.Table.get_id('Forecast'), 'children')] ) def update_graphs(dist_state): distribution = dist.Table.load(dist_state) pdf = go.Figure([distribution.pdf_plot(), distribution.bar_plot()]) pdf.update_layout(transition_duration=500, title='PDF') cdf = go.Figure([distribution.cdf_plot()]) cdf.update_layout(transition_duration=500, title='CDF') return [dcc.Graph(figure=pdf), dcc.Graph(figure=cdf)] if __name__ == '__main__': app.run_server(debug=True) Run the app with: $ python app.py Open your browser and navigate to http://localhost:8050/ .","title":"Examples"},{"location":"distributions/table/#dash_fcastdistributionstable","text":"class dash_fcast.distributions. Table ( id, bins=[0, 0.25, 0.5, 0.75, 1], pdf=[0.25, 0.25, 0.25, 0.25], datatable={}, row_addable=False, smoother=False, *args, **kwargs ) [source] Tabular distribution elicitation. Parameters and attributes: id : str, default Distribution identifier. bins : list of scalars, default=[0, .25, .5, .75, 1] List of 'break points' for the bins. The first bin starts at bins[0] . The last bin ends at bins[-1] . pdf : list of scalars, default=[.25, .25, .25, .25] Probability density function. This is the amount of probability mass in each bin. Must sum to 1 and len(pdf) must be len(bins)-1 . datatable : dict, default={} Keyword arguments for the datatable associated with the table distribution. See https://dash.plotly.com/datatable . row_addable : bool, default=False Indicates whether the forecaster can add rows. smoother : bool, default=False Indicates whether to use a smoother for interpolation. See https://dsbowen.github.io/smoother/ . *args, **kwargs : Arguments and keyword arguments passed to super().__init__ .","title":"dash_fcast.distributions.Table"},{"location":"distributions/table/#methods","text":"get_id ( id, type='state' ) [source] Parameters: id : str type : str, default='state' Type of object associated with the moments distribution. Returns: id dictionary : dict Dictionary identifier. elicitation ( self, bins=[0, 0.25, 0.5, 0.75, 1], pdf=[0.25, 0.25, 0.25, 0.25], datatable={}, row_addable=False ) [source] Parameters: bins : list of scalars or numpy.array, default=[0, .25, .5, .75, 1] pdf : list of scalars or numpy.array, default=[.25, .25, .25, .25] datatable : dict, default={} row_addable : bool, default=False Returns: elicitation elements : list of dash elements Dash elements used to elicit the distribution. get_columns ( self ) [source] Returns: columns : list of dict List of dictionaries specifying the datatable columns. See https://dash.plotly.com/datatable , get_data ( self, bins=None, pdf=None ) [source] Parameters: bins : list of float or numpy.array or None, default=None If None , use self.bins . pdf : list of float or numpy.array or None, default=None If None , use self.pdf . Returns: records : list of dict Datatable data in records format. register_callbacks ( app ) [source] Register dash callbacks for table distributions. Parameters: app : dash.Dash App with which to register callbacks. fit ( self, bins=None, pdf=None, derivative=2 ) [source] Fit the smoother given masses constraints. Parameters: bins : list of float or numpy.array Ordered list of bin break points. If None , use self.bins . pdf : list of float or numpy.array Probability density function. This is the amount of probability mass in each bin. Must sum to 1 and len(pdf) should be len(bins)-1 . If None , use self.pdf . derivative : int, default=2 Deriviate of the derivative smoothing function to maximize. e.g. 2 means the smoother will minimize the mean squaure second derivative. Returns: self : dump ( self ) [source] Dump the table distribution state dictionary in JSON format. Returns: state : dict, JSON load ( cls, state_dict ) [source] Load a table distribution from its state dictionary. Parameters: state_dict : dict Output of Table.dump . Returns: table : Table pdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Scatter . Returns: scatter : go.Scatter. Scatter plot of the pdf. cdf_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Scatter . Returns: scatter : go.Scatter Scatter plot of the cdf. bar_plot ( self, **kwargs ) [source] Parameters: **kwargs : Keyword arguments for go.Bar . Returns: bar plot : go.Bar Bar plot of the pdf in the datatable.","title":"Methods"},{"location":"distributions/utils/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Distributions dash_fcast.distributions. load_distributions def dash_fcast.distributions. load_distributions ( dist_states ) [source] Parameters: dist_states : list of JSON dictionaries List of distribution state dictionaries. Returns: distributions : list of distributions List of distributions recovered from the state dictionaries. dash_fcast.distributions. load_distribution def dash_fcast.distributions. load_distribution ( dist_state ) [source] Parameters: dist_state : JSON dictionary Distribution state dictionary. Returns: distribution : Distribution recovered from the state dictionary.","title":"Utilities"},{"location":"distributions/utils/#distributions","text":"","title":"Distributions"},{"location":"distributions/utils/#dash_fcastdistributionsload_distributions","text":"def dash_fcast.distributions. load_distributions ( dist_states ) [source] Parameters: dist_states : list of JSON dictionaries List of distribution state dictionaries. Returns: distributions : list of distributions List of distributions recovered from the state dictionaries.","title":"dash_fcast.distributions.load_distributions"},{"location":"distributions/utils/#dash_fcastdistributionsload_distribution","text":"def dash_fcast.distributions. load_distribution ( dist_state ) [source] Parameters: dist_state : JSON dictionary Distribution state dictionary. Returns: distribution : Distribution recovered from the state dictionary.","title":"dash_fcast.distributions.load_distribution"}]}